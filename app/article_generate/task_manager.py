import uuid
import weakref
import threading
import time
from typing import Optional, Generator

from database import db
from .models import ArticleConfig, UserFile
from ..utils.model_to_dict import model_to_dict
from ..utils.tavily_search import do_tavily_ai_search
from ..utils.deal_prompt import extract_search_keywords
from ..utils.RAG_search import do_local_RAG_search_by_files
from ..utils.internet_search.google_search import do_google_serp_search
from ..utils.article_generation.outline_generate import outline_generate
from ..utils.article_generation.article_generate import article_generate

from sqlalchemy import select

# task queue
_tasks: list["Task"] = []
# task id maps to task.
id_map: dict[str, "Task"] = {}

def clear_task_by_config_id(config_id):
  """
  clear all tasks related to config_id in the map.
  """
  pass

class Task:
  """
  Manager for article generation task.
  """
  @staticmethod
  def get_tasks_by_config_id(config_id):
    result: list[Task] = []
    for task in _tasks:
      if task.config_id == config_id:
        result.append(task)
    return result
  
  @staticmethod
  def get_task_by_id(id) -> "Task":
    return id_map.get(id)
  
  def __init__(self, config_id, article_title=None):
    self.id = str(uuid.uuid4())
    self.config_id = config_id
    self.aritle_title = article_title
    _tasks.append(self)
    clear_task_by_config_id(config_id)
    id_map[self.id] = self
  
  id: str
  config_id: int # Every task has its corresponding article-gen config
  search_ready: bool = False
  network_RAG_search_ready: bool = False
  local_RAG_search_ready: bool = False
  outline_ready: bool = False
  document_ready: bool = False # this not means document has been generated, but the document generator is ready to be iterated
  is_generated: bool = False # document has been totally generated.
  
  search_result = None
  network_RAG_search_result = None
  local_RAG_search_result = None
  outline_result = None
  aritle_title = None
  document_generator : Optional[Generator | None] = None
  
  def run(self):
    """
    Run an article generation task.
    Considering the convenience, a task generates an entire article step by step sequentially:
    1. search the internet
    2. search the network RAG if setted
    3. search the local RAG if setted
    4. generate the article based on these results.
    
    Once `get_document()` called returns the entire document(not None) successfully, 
    `clear()` should be not be forgotten to call so that task can be expunged from the tasks queue and destroyed.
    """
    
    # 这里选择使用线程来运行文章生成任务
    # Flask 并不希望用户创建线程: https://flask.palletsprojects.com/en/stable/design/#thread-locals
    # 使用线程会导致 Flask 上下文丢失。解决方案: 把任务需要的信息拿到, 传给线程。
    config = db.session.get(ArticleConfig, self.config_id)
    if config.local_RAG:
      stmt = select(UserFile).where(UserFile.config_id==self.config_id)
      files_results = db.session.execute(stmt)
      local_files = []
      for row in files_results:
        file = {
          "file_name": row[0].file_name,
          "file_data": row[0].file_data,
          "config_id": row[0].config_id,
        }
        local_files.append(file)
      
    config = model_to_dict(config)
    
    args = [config, ]
    if (local_files):
      args.append(local_files)
      
    try:
      thread = threading.Thread(target=self._run, args=args)
      thread.start()
    except Exception as e:
      print(f"任务 {self.id} 运行期间发生错误: {e}")
      
    
  def get_status(self, status_wanted) -> bool:
    return getattr(self, status_wanted)
  
  def _clear(self):
    """
    Clear the task when document is generated totally.
    After clearing, you can still get all results the task have generated by the reference to it, 
    or call `get_document_generator()` to re-generate document by the searching results and current outline.
    but the task actually has been expunged from the tasks queue.
    """
    _tasks.remove(self)
    
  def get_document_generator(self):
    # deal with re-generate request case
    if (self.is_generated):
      self.document_generator = article_generate(
        self.search_result, 
        self.network_RAG_search_result, 
        self.local_RAG_search_result,
        self.outline_result
      )
    
    return self.document_generator
    
  def _run(self, config, files=None):
    print("task {}: 开始运行...".format(self.id))
  
    net_RAG = config["networking_RAG"]
    local_RAG = config["local_RAG"]
    prompt = config["article_prompt"]["content"]
    step_by_step = config["step_by_step"]
    search_keywords = extract_search_keywords(prompt)
    
    # self._search_internet(search_keywords, config)
    time.sleep(0.3)
    self.search_result = {}
    self.search_ready = True
    print("task {}: 搜索完毕".format(self.id))
    
    if net_RAG:
      # self._search_network_RAG(search_keywords)
      time.sleep(0.3)
      self.network_RAG_search_result = {}
      self.network_RAG_search_ready = True
      print("task {}: 远程RAG检索完毕".format(self.id))
      
    if local_RAG and files:
      # self._search_local_RAG(files, prompt)
      time.sleep(0.3)
      self.local_RAG_search_result = {}
      self.local_RAG_search_ready = True
      print("task {}: 本地支持库检索完毕".format(self.id))
      
    if step_by_step:
      """
      Step by step is True means an outline will be generated firstly, rather than generating the document directly.
      User should setup document generation by `generate_document()` on their own.
      """
      # self._geneate_outline()
      time.sleep(0.3)
      self.outline_result = "test...."
      self.outline_ready = True
      print("task {}: 大纲生成完毕".format(self.id))
    
    document_generator = self._generate_document(
      self.search_result, 
      self.network_RAG_search_result, 
      self.local_RAG_search_result,
      self.outline_result # this param will be None is step_by_step is False
    )
    self.document_generator = document_generator
    self.document_ready = True
    print("task {} 文章生成器准备完毕".format(self.id))
  
  def _geneate_outline(self):
    self.outline_result = outline_generate(
      self.search_result, 
      self.network_RAG_search_result, 
      self.local_RAG_search_result,
    )
  
  def _search_internet(self, search_keywords: list[str], config: dict):
    if (config["search_engine"] == 'google'):
      self.search_result = do_google_serp_search(search_keywords, config)
    elif(config["search_engine"] == 'edge'):
      pass
    elif(config["search_engine"] == "baidu"):
      pass
    
  
  def _search_network_RAG(self, search_keywords: list[str], urls: list[str]=[]):
    self.network_RAG_search_result = do_tavily_ai_search(search_keywords, options={
      "urls_included": urls
    })
  
  def _search_local_RAG(self, files, query, result_count=4):
    documents_searched = do_local_RAG_search_by_files(files, query, result_count)
    self.local_RAG_search_result = [doc.page_content for doc in documents_searched]
  
  def _generate_document(self, *args):
    generator = article_generate(*args)
    def clear_wrapper(generator):
      for result in generator:
        yield result
      # mark the task as is_generated and clear it.
      self.is_generated = True
      self._clear()
      
    return clear_wrapper(generator)

  def to_dict(self):
    return {
      "id": self.id,
      "config_id": self.config_id,
      "search_ready": self.search_ready,
      "outline_ready": self.outline_ready,
      "network_RAG_search_ready": self.network_RAG_search_ready,
      "local_RAG_search_ready": self.local_RAG_search_ready,
      "document_ready": self.document_ready,
    }